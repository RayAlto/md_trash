# 数据编码

现在把输入的数据变成一串 bit ，比如编码 `HELLO WORLD` ：

## 选择能满足要求的最小版本

在[这里](./91.character-capacities.md "字符容量表")可以查出指定版本、编码模式、容错等级对应的可以容纳的最多字符数量

> 这个好像不能通过一个表达式计算

`HELLO WORLD` 可以选择数字字母模式进行编码；只有 11 个字符，可以选择版本 1 、容错等级 Q （最大可以容纳 16 个字符）

## 添加模式指示符

| 模式         | 指示符 |
| ------------ | ------ |
| 数字模式     | `0001` |
| 数字字母模式 | `0010` |
| 二进制模式   | `0100` |
| 日文模式     | `1000` |
| ECI 模式     | `0111` |

这里用数字字母模式就可以，加上 `0010` 现在的结果是：

```plain
0010
```

## 添加字符数量指示符

根据使用的模式，字符数量指示符的 bit 个数是固定的：

| 版本/模式    | 数字模式 | 数字字母模式 | 二进制模式 | 日文模式 |
| ------------ | -------- | ------------ | ---------- | -------- |
| 版本 1 - 9   | 10 bits  | 9 bits       | 8 bits     | 8 bits   |
| 版本 10 - 26 | 12 bits  | 11 bits      | 16 bits    | 10 bits  |
| 版本 27 - 40 | 14 bits  | 13 bits      | 16 bits    | 12 bits  |

先把输入的字符数量变成二进制，如果 bit 个数不够就从左 pad `0` ， `HELLO WORLD` 有 11 个字符，转化成二进制就是 `1011` ，但按照要求这个指示符应该有 9 个 bit ， pad 之后就是 `000001011` ，现在的结果是：

```plain
0010 000001011
```

## 按照对应的编码模式对数据进行编码

用数字字母模式，编码的结果是 `01100001011 01111000110 10001011100 10110111000 10011010100 001101` ，现在的结果是：

```plain
0010 000001011 01100001011 01111000110 10001011100 10110111000 10011010100 001101
```

> 日文模式就不记录了

### 数字模式的编码方式

比如对 `1919810` 进行编码。先每三个数字分一组，变成 `191` `981` `0` ，然后把每一组作为一个十进制数转化成二进制

- 三位数转化成 10 个 bit 的二进制数
- 两位数（包括 `023` 这种有一个 `0` 开头的）转化成 7 个 bit 的二进制字数
- 一位数（包括 `004` 这红有两个 `0` 开头的）转化成 4 个 bit 的二进制数

变成 `0010111111` `1111010101` `0000`

### 数字字母模式的编码方式

> 每个字符对应的值可以在[这个表格](./92.alphanumeric-table.md "数字字母模式字符值表格")里查到

比如对 `HELLO` 进行编码。先每两个字符分一组，变成 `HE` `LL` `O` ，然后把每一组转化成二进制

- 含有两个字符的组比如 `HE` ， `H` 对应 17 ， `E` 对应 14 ，把左边字符（ `H` ）对应的值乘以 45 再加上右边字符（ `E` ）对应的值，也就是 `17 * 45 + 14 = 779` ，把它转化成 11 位的二进制数： `01100001011` （不够就在左边 pad `0` ）
- 只有一个字符的组比如 `O` ，查出对应值是 24 ，直接转化成 6 位的二进制数： `011000` （不够就在左边 pad `0` ）

变成 `01100001011` `01111000110` `011000`

### 二进制模式的编码方式

比如对 `路段a` 进行编码。直接写出对应的 UTF-8 bytes ： `0xe8` `0xb7` `0xaf` `0xe6` `0xae` `0xb5` `0x61` ，然后变成 8 位的二进制数： `11101000` `10110111` `10101111` `11100110` `10101110` `10110101` `01100001`

## 整理结果

目前得出了三个部分：

| 模式指示符 | 字符数量指示符 | 数据编码                                                             |
| ---------- | -------------- | -------------------------------------------------------------------- |
| `0010`     | `000001011`    | `01100001011 01111000110 10001011100 10110111000 10011010100 001101` |

### 查出当前版本和纠错等级应该有的总 bit 数

去[这个表](./93.error-correction-table.md "纠错相关信息表")看选择的版本、纠错等级对应的“总字节”列的值， `1-Q` 对应的就是 13 ，表示这个版本应该有 13 bytes （ 104 bits ）

> 这个好像也不能直接用某种表达式计算出来

### 添加终止符

如果现在的结果长度小于上面查出的长度的话就要加终止符：

- 缺 4+ 个 bit ：加上终止符 `0000`
- 缺 4 个 bit ：加上终止符 `0000`
- 缺 3 个 bit ：加上终止符 `000`
- 缺 2 个 bit ：加上终止符 `00`
- 缺 1 个 bit ：加上终止符 `0`
- 不缺：那就别动

目前的结果一共 74 bits ，小于应有的 104 bits ，而且缺的多于 4 bits ，加上终止符 `0000` ，现在的结果：

| 模式指示符 | 字符数量指示符 | 数据编码                                                             | 终止符 |
| ---------- | -------------- | -------------------------------------------------------------------- | ------ |
| `0010`     | `000001011`    | `01100001011 01111000110 10001011100 10110111000 10011010100 001101` | `0000` |

### 填充成 bytes

把结果整理成 bytes ：

```plain
00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 010000
```

不满一个 byte 的在右边 pad `0` ：

```plain
00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000
```

### 最后的填充

现在的结果一共是 10 bytes ，距离规定的 13 bytes 还缺 3 个 byte ，这时需要循环添加 `11101100` (`0xec`) `00010001` (`0x11`) 这两个 byte ，直到满足规定：

```plain
00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 11101100 00010001 11101100
```
