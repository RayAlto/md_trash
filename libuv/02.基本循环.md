# åŸºæœ¬å¾ªç¯

libuv æ˜¯äº‹ä»¶é©±åŠ¨çš„ï¼Œæˆ‘åªéœ€è¦å…³æ³¨äº‹ä»¶å’Œå®ƒçš„å›è°ƒï¼Œå…¶ä»–çš„äº¤ç»™ libuv ã€‚

## Hello World

ä¸‹é¢åˆ›å»ºä¸€ä¸ªç©ºçš„å¾ªç¯ï¼Œä»€ä¹ˆéƒ½ä¸åšç›´æ¥é€€å‡ºã€‚

```c++
#include <memory>
#include <iostream>

#include "uv.h"

int main(int argc, char const* argv[]) {
    std::unique_ptr<uv_loop_t> loop = std::make_unique<uv_loop_t>();
    uv_loop_init(loop.get());

    std::cout << "æˆ‘æ»´ä»»åŠ¡å®Œæˆè¾£ï¼" << std::endl;
    uv_run(loop.get(), UV_RUN_DEFAULT);

    uv_loop_close(loop.get());
    return 0;
}
```

`uv_loop_init()` å¯ä»¥åˆå§‹åŒ–ä¸€ä¸ªå¾ªç¯ï¼Œæœ€åéœ€è¦ä½¿ç”¨ `uv_loop_close` å…³é—­å¾ªç¯ï¼Œé‡Šæ”¾èµ„æºã€‚ libuv æœ‰ä¸€ä¸ªé»˜è®¤çš„å¾ªç¯ï¼Œå¯ä»¥é€šè¿‡ `uv_default_loop()` è·å–ï¼Œå¦‚æœåªéœ€è¦ä¸€ä¸ªå¾ªç¯çš„è¯å¯ä»¥ç›´æ¥ç”¨è¿™ä¸ªã€‚

## é”™è¯¯å¤„ç†

åˆå§‹åŒ–å‡½æ•°/åŒæ­¥æ‰§è¡Œçš„å‡½æ•°åœ¨æ‰§è¡Œå¤±è´¥æ—¶ä¼šè¿”å›ä»£è¡¨é”™è¯¯çš„è´Ÿæ•°ã€å¼‚æ­¥æ‰§è¡Œçš„å‡½æ•°ä¼šåœ¨æ‰§è¡Œå¤±è´¥æ—¶ä¼ ç»™å›è°ƒå‡½æ•°ä¸€ä¸ªçŠ¶æ€å‚æ•°ã€‚é”™è¯¯ä¿¡æ¯ä¸€èˆ¬æ˜¯ `UV_EXXX` å®ï¼Œå¯ä»¥é€šè¿‡ `uv_strerror()` è·å–é”™è¯¯ä¿¡æ¯ã€é€šè¿‡ `uv_err_name()` è·å–é”™è¯¯åå­—ã€‚

I/O å‡½æ•°ï¼ˆä¾‹å¦‚æ–‡ä»¶/ Socket ç­‰ï¼‰çš„å›è°ƒå‡½æ•°ä¼šè¢«ä¼ é€’ä¸€ä¸ª `nread` å‚æ•°ï¼Œå½“ `nread` å°äº 0 ï¼Œå°±ä»£è¡¨å‘ç”Ÿäº†é”™è¯¯ï¼Œä½†å¦‚æœæ˜¯ `UV_EOF` åˆ™ä»£è¡¨è¯»åˆ°äº†æ–‡ä»¶å°¾ï¼Œéœ€è¦å¦å¤–å¤„ç†ã€‚

## Handler å’Œ Reqeust

é€šè¿‡ handler å¯ä»¥å®Œæˆå„ç§å·¥ä½œã€æ¯ä¸ª handler ä¼šå¯¹åº”å¾ˆå¤š request

- æ¯ä¸ª handler ï¼ˆç”šè‡³ `uv_loop_t` ï¼‰éƒ½æœ‰ä¸€ä¸ª `void* data` æˆå‘˜ç”¨æ¥ä¼ é€’ä¿¡æ¯

### Idle

ç”¨ idle handler ç®€ç®€å•å•æ‰“ä¸ª ğŸ¦¶ï¼š

```c++
#include <chrono>
#include <iostream>
#include <thread>

#include "uv.h"

int main(int argc, char const* argv[]) {
    int count = 0;
    uv_idle_t idler;
    // å§ count ä½œä¸º data ä¼ è¿› handler é‡Œ
    idler.data = &count;
    // ç»å…¸åˆå§‹åŒ–
    uv_idle_init(uv_default_loop(), &idler);
    // lambda ä½œä¸ºå›è°ƒï¼Œä¸æ”¯æŒæ•è·
    uv_idle_start(&idler, [](uv_idle_t* handle) -> void {
        // æŠŠ count å–å‡ºæ¥
        int& count = *(reinterpret_cast<int*>(handle->data));
        if (count < 5) {
            std::cout << "ğŸ’§" << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(1));
            count += 1;
        }
        else {
            // æœ‰å§‹æœ‰ç»ˆ
            uv_idle_stop(handle);
        }
    });

    std::cout << "æ‰“ä¸ªğŸ¦¶å…ˆ..." << std::endl;
    uv_run(uv_default_loop(), UV_RUN_DEFAULT);

    uv_loop_close(uv_default_loop());
    return 0;
}
```

è¾“å‡ºï¼š

```plain
æ‰“ä¸ªğŸ¦¶å…ˆ...
ğŸ’§
ğŸ’§
ğŸ’§
ğŸ’§
ğŸ’§
```
