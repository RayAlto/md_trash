# Git 学习笔记 03

> 每一个 commit 都有一个 tree 索引，这个 tree 记录 commit 的目录结构以及一些 blob 索引，每个 blob 对应一个文件的变更

## 1. branch

> 每个仓库都有一个主分支 master ， master 一般指向主分支的最新一次 commit ；同时仓库还有一个 HEAD 表示本地工作分支，也就是说很大可能也指向主分支的最新一次 commit

### 1.1. 创建分支

```shell
git branch [branch_name]
```

### 1.2. 切换分支

```shell
# 切换到现有分支
git checkout [branch]
# 创建一个新的分支并切换到新分支
git checkout -b [new_branch_name]
# 等价于：
#     git branch [new_branch_name]
#     git checkout [new_branch_name]
```

现在像一个专家一样使用 Git 进行版本控制，想要给项目添加一个新 feature ，可以创建一个新的 branch ，比如叫 `feature1` ：

```shell
git checkout -b feature1
```

然后写了一些相关代码， commit 了一下，现在的情况大概就是这样：

![branch-feature1](../imgs/git001.svg)

突然发现项目原来有一个致命的 BUG ，需要抓紧修复，一个 Git 专家大概会切换回 master 分支，再创建一个紧急修复用的分支用于修复工作，比如叫 `hotfix` ：

```shell
git checkout master
git checkout -b hotfix
```

然后修复了这个 BUG ， commit 了一下，现在的情况大概是这样：

![branch-hotfix](../imgs/git002.svg)

### 1.3. 合并分支

#### 1.3.1. `Fast-forward`

书接上回， `hotfix` 分支经过一系列测试被证明修复了这个 BUG ，一个 Git 专家大概会把这个 `hotfix` 分支合并进 `master` ：

```shell
git checkout master
git merge hotfix
```

因为 `hotfix` 分支指向的 commit `C4` 是 `master` 分支指向的 commit `C2` 的直接后继，所以 merge 时 git 会提示它在进行 Fast-forward ，现在的情况大概是这样：

![merge-fast-forward-hotfix](../imgs/git003.svg)

现在 `hotfix` 分支不再被需要了：

```shell
git branch -d hotfix
```

现在应该切换回 `feature1` 分支继续之前的工作：

```shell
git checkout feature1
```

#### 1.3.2. `recursive`

经过一些 commit ， feature 成功被实现了，现在的情况大概是这样：

![feature1-branch-ok](../imgs/git004.svg)

一个 Git 专家可能会把这个 `feature1` 分支合并进 `master` ：

```shell
git checkout master
git merge feature1
```

如果这个专家运气足够好，那么 merge 应该会成功，新的 master 分支既打了之前 hotfix 分支的 pathc ，又打了 feature1 分支的 patch ，情况大概是这样：

![merge-recursive-feature1](../imgs/git005.svg)
